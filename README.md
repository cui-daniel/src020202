## 单例模式  
  单例模式是为了保证在一定范围内有且只有一个实例的方法
  * 懒汉式单例
    * 简单懒汉模式  
      构造简单，线程不安全
    * 双检查懒汉式单例  
      试用synchronized保持线程同步，第一次检查不加锁，保证效率，第二次检查加锁保证同步，由于使用synchronized会造成一定的性能问题
  * 饿汉试单例  
    单例在类加载的时候赋值，由JVM保证线程安全，由于是在类加载时初始化，会造成在未使用单例的情况下就已经占用了内存的问题
  * 枚举式单例
    枚举式单例利用了枚举的特性从JVM层面解决了线程安全及反射和序列化破坏单例的问题，是比较推荐的一种方式
  * 注册式单例  
    注册式单例只能通过业务逻辑保证单例，用于需要多个单例的情况
  * 内部类单例  
    内部类单例是通过内部类加载特性实现的一种懒汉式单例，由JVM保证线程安全  
    当外部调用获取单例的静态方法时，JVM判断内部类是否加载，如果已加载直接返回静态类的静态成员；如果未加载内部类则执行内部类加载操作，内部类加载时初始化静态成员，初始化完成后返回静态成员的值，完成单例的获取
  * ThreadLocal单例  
    ThreadLocal单例利用ThreadLocal实现线程内单例，无法保证全局单例
## 原型模式  
  原型模式的主要目的是提供一种快速实例化对象的途径，用于构建大量对象或对象构造方法过于复杂等情况
  * 深克隆  
    深克隆是置复制所有成员的值的克隆方式，每一个成员都是新的对象，也就是说克隆自身的同时，成员以及成员的成员都进行深克隆
  * 浅克隆  
    浅克隆是指复制引用的一种克隆方式，克隆的结果可能是新对象和老对象持有同一个对象的引用
  * 解析方式（我自己取的名字，仅供参考）  
    分析传递的值，用分析结果构建对象，并对对象的成员进行初始化
